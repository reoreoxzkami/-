<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ GPSã‚¢ãƒ—ãƒªï¼ˆå˜ä¸€HTMLç‰ˆï¼‰</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b1220;
        --card: #151f33;
        --text: #e8eefc;
        --muted: #9eadcc;
        --accent: #3b82f6;
        --accent-2: #22c55e;
        --danger: #f87171;
        --border: #2b3a59;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: Inter, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
        background: radial-gradient(circle at 10% 0%, #17294d 0, var(--bg) 40%);
        color: var(--text);
      }
      .container { width: min(1100px, 94%); margin: 1.25rem auto 2rem; display: grid; gap: 1rem; }
      .card { background: color-mix(in hsl, var(--card) 92%, black); border: 1px solid var(--border); border-radius: 14px; padding: 1rem; }
      h1 { margin: 0 0 0.7rem; }
      p { margin: 0; color: var(--muted); }
      .layout { display: grid; gap: 1rem; grid-template-columns: 1fr; }
      @media (min-width: 900px) { .layout { grid-template-columns: 1.45fr 1fr; } }
      #map { width: 100%; height: min(62vh, 520px); border-radius: 12px; border: 1px solid var(--border); }
      .controls { display: flex; flex-wrap: wrap; gap: 0.65rem; margin-bottom: 0.9rem; }
      button { border: none; background: var(--accent); color: #fff; border-radius: 10px; padding: 0.65rem 0.95rem; font-size: 0.95rem; font-weight: 700; cursor: pointer; }
      button.secondary { background: #334155; }
      button.success { background: var(--accent-2); }
      button:disabled { opacity: 0.65; cursor: not-allowed; }
      .status { min-height: 1.4rem; color: var(--muted); }
      .status.error { color: var(--danger); }
      .grid { display: grid; gap: 0.65rem; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
      .metric { border: 1px solid var(--border); border-radius: 10px; padding: 0.7rem; background: #10192b; }
      .label { display: block; color: var(--muted); font-size: 0.8rem; margin-bottom: 0.15rem; }
      .value { font-size: 1.02rem; font-weight: 700; }
      .history { margin-top: 0.8rem; max-height: 250px; overflow: auto; border: 1px solid var(--border); border-radius: 10px; }
      table { width: 100%; border-collapse: collapse; font-size: 0.84rem; }
      th, td { text-align: left; padding: 0.45rem 0.5rem; border-bottom: 1px solid #213150; white-space: nowrap; }
      th { position: sticky; top: 0; background: #172540; z-index: 1; }
      .footnote { font-size: 0.8rem; color: var(--muted); }
    </style>
  </head>
  <body>
    <main class="container">
      <section class="card">
        <h1>ğŸ“ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ GPSã‚¢ãƒ—ãƒªï¼ˆå˜ä¸€HTMLç‰ˆï¼‰</h1>
        <p>å‘ãã®è¡¨ç¤ºå®‰å®šåŒ–ï¼ˆGPS/ç§»å‹•æ–¹ä½å„ªå…ˆï¼‰ã¨ã€ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒå‡ºã«ãã„è¿½è·¡è¨­å®šã«èª¿æ•´æ¸ˆã¿ã§ã™ã€‚</p>
      </section>

      <section class="layout">
        <section class="card"><div id="map" aria-label="åœ°å›³"></div></section>
        <section class="card">
          <div class="controls">
            <button id="startBtn" class="success">è¿½è·¡é–‹å§‹</button>
            <button id="stopBtn" class="secondary" disabled>è¿½è·¡åœæ­¢</button>
            <button id="centerBtn" class="secondary">ç¾åœ¨åœ°ã¸ç§»å‹•</button>
            <button id="clearBtn" class="secondary">è»Œè·¡ã‚¯ãƒªã‚¢</button>
          </div>
          <div id="status" class="status">ã€Œè¿½è·¡é–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>

          <div class="grid" aria-live="polite">
            <div class="metric"><span class="label">ç·¯åº¦</span><span class="value" id="lat">--</span></div>
            <div class="metric"><span class="label">çµŒåº¦</span><span class="value" id="lng">--</span></div>
            <div class="metric"><span class="label">ç²¾åº¦</span><span class="value" id="accuracy">--</span></div>
            <div class="metric"><span class="label">é€Ÿåº¦</span><span class="value" id="speed">--</span></div>
            <div class="metric"><span class="label">å‘ãï¼ˆå¸¸æ™‚ï¼‰</span><span class="value" id="heading">å–å¾—å¾…ã¡</span></div>
            <div class="metric"><span class="label">ç´¯è¨ˆè·é›¢</span><span class="value" id="distance">0 m</span></div>
          </div>

          <div class="history">
            <table>
              <thead><tr><th>æ™‚åˆ»</th><th>ç·¯åº¦</th><th>çµŒåº¦</th><th>é€Ÿåº¦</th></tr></thead>
              <tbody id="historyBody"><tr><td colspan="4">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</td></tr></tbody>
            </table>
          </div>
        </section>
      </section>

      <section class="card footnote">
        ä½ç½®æƒ…å ±ã¯ HTTPSï¼ˆã¾ãŸã¯ localhostï¼‰ã§åˆ©ç”¨ã§ãã¾ã™ã€‚ç«¯æœ«æ–¹ä½ã¯æ©Ÿç¨®ãƒ»æ¨©é™çŠ¶æ…‹ã§å–å¾—ã§ããªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
      </section>
    </main>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
      const statusEl = document.getElementById('status');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const centerBtn = document.getElementById('centerBtn');
      const clearBtn = document.getElementById('clearBtn');
      const historyBody = document.getElementById('historyBody');
      const latEl = document.getElementById('lat');
      const lngEl = document.getElementById('lng');
      const accuracyEl = document.getElementById('accuracy');
      const speedEl = document.getElementById('speed');
      const headingEl = document.getElementById('heading');
      const distanceEl = document.getElementById('distance');

      const map = L.map('map').setView([35.681236, 139.767125], 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map);
      const marker = L.marker([35.681236, 139.767125]).addTo(map);
      const polyline = L.polyline([], { color: '#3b82f6', weight: 4 }).addTo(map);

      const MIN_ACCEPTABLE_ACCURACY_M = 150;
      const MAX_REASONABLE_SPEED_MPS = 55;
      const MIN_MOVEMENT_FOR_BEARING_M = 3;
      const STALE_TIMEOUT_MS = 25000;
      const EXTRA_POLL_MS = 5000;

      let watchId = null;
      let path = [];
      let totalDistanceM = 0;
      let lastUpdateAt = 0;
      let staleCheckTimer = null;
      let extraPollTimer = null;

      let deviceHeadingDeg = null;
      let lastHeading = null;
      let lastHeadingSource = '';
      let lastHeadingAt = 0;

      function setStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.classList.toggle('error', isError);
      }

      function formatSpeed(mps) {
        if (typeof mps !== 'number' || Number.isNaN(mps)) return '--';
        return `${(mps * 3.6).toFixed(1)} km/h`;
      }

      function headingToCardinal(deg) {
        const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
        return dirs[Math.round(deg / 45) % 8];
      }

      function bearingDegrees(from, to) {
        const toRad = (d) => (d * Math.PI) / 180;
        const toDeg = (r) => (r * 180) / Math.PI;
        const y = Math.sin(toRad(to.lng - from.lng)) * Math.cos(toRad(to.lat));
        const x = Math.cos(toRad(from.lat)) * Math.sin(toRad(to.lat))
          - Math.sin(toRad(from.lat)) * Math.cos(toRad(to.lat)) * Math.cos(toRad(to.lng - from.lng));
        return (toDeg(Math.atan2(y, x)) + 360) % 360;
      }

      function haversineMeters(a, b) {
        const R = 6371000;
        const toRad = (d) => (d * Math.PI) / 180;
        const dLat = toRad(b.lat - a.lat);
        const dLng = toRad(b.lng - a.lng);
        const aa = Math.sin(dLat / 2) ** 2
          + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLng / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
      }

      function setHeading(deg, source) {
        const normalized = ((deg % 360) + 360) % 360;
        lastHeading = normalized;
        lastHeadingSource = source;
        lastHeadingAt = Date.now();
        headingEl.textContent = `${Math.round(normalized)}Â° ${headingToCardinal(normalized)} (${source})`;
      }

      function renderHeading(currentPoint = null) {
        if (currentPoint && Number.isFinite(currentPoint.heading)
          && Number.isFinite(currentPoint.speed) && currentPoint.speed > 0.7) {
          setHeading(currentPoint.heading, 'GPS');
          return;
        }

        if (path.length >= 2) {
          const prev = path[path.length - 2];
          const curr = path[path.length - 1];
          const movementM = haversineMeters(prev, curr);
          if (movementM >= MIN_MOVEMENT_FOR_BEARING_M) {
            setHeading(bearingDegrees(prev, curr), 'ç§»å‹•');
            return;
          }
        }

        if (Number.isFinite(deviceHeadingDeg)) {
          setHeading(deviceHeadingDeg, 'ç«¯æœ«');
          return;
        }

        if (Number.isFinite(lastHeading)) {
          headingEl.textContent = `${Math.round(lastHeading)}Â° ${headingToCardinal(lastHeading)} (${lastHeadingSource}:ä¿æŒ)`;
          return;
        }

        headingEl.textContent = 'å–å¾—å¾…ã¡';
      }

      function restartTrackingWatch() {
        if (watchId !== null) navigator.geolocation.clearWatch(watchId);
        watchId = navigator.geolocation.watchPosition(updatePosition, handleError, {
          enableHighAccuracy: true,
          maximumAge: 2000,
          timeout: 20000,
        });
      }

      function ensureExtraPoll() {
        if (extraPollTimer !== null) return;
        extraPollTimer = setInterval(() => {
          if (watchId === null) return;
          navigator.geolocation.getCurrentPosition(updatePosition, (error) => {
            if (error.code !== 3) handleError(error);
          }, {
            enableHighAccuracy: true,
            maximumAge: 2000,
            timeout: 12000,
          });
        }, EXTRA_POLL_MS);
      }

      function clearExtraPoll() {
        if (extraPollTimer !== null) {
          clearInterval(extraPollTimer);
          extraPollTimer = null;
        }
      }

      function ensureStaleCheckTimer() {
        if (staleCheckTimer !== null) return;
        staleCheckTimer = setInterval(() => {
          if (watchId === null || !lastUpdateAt) return;
          if (Date.now() - lastUpdateAt >= STALE_TIMEOUT_MS) {
            setStatus('æ›´æ–°ãŒæ­¢ã¾ã£ãŸãŸã‚å†æ¥ç¶šã—ã¦ã„ã¾ã™...');
            restartTrackingWatch();
            lastUpdateAt = Date.now();
          }
        }, 4000);
      }

      function clearStaleCheckTimer() {
        if (staleCheckTimer !== null) {
          clearInterval(staleCheckTimer);
          staleCheckTimer = null;
        }
      }

      function isLikelyGpsJump(point) {
        if (path.length === 0) return false;
        const prev = path[path.length - 1];
        const dtSec = Math.max((point.timestamp - prev.timestamp) / 1000, 1);
        const distanceM = haversineMeters(prev, point);
        const calcSpeed = distanceM / dtSec;
        const sensorSpeed = Number.isFinite(point.speed) ? point.speed : calcSpeed;
        return calcSpeed > MAX_REASONABLE_SPEED_MPS && sensorSpeed > MAX_REASONABLE_SPEED_MPS;
      }

      function renderHistory() {
        if (path.length === 0) {
          historyBody.innerHTML = '<tr><td colspan="4">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</td></tr>';
          return;
        }
        historyBody.innerHTML = '';
        path.slice(-20).reverse().forEach((point) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${new Date(point.timestamp).toLocaleTimeString()}</td><td>${point.lat.toFixed(6)}</td><td>${point.lng.toFixed(6)}</td><td>${formatSpeed(point.speed)}</td>`;
          historyBody.appendChild(tr);
        });
      }

      function updatePosition(pos) {
        const { latitude, longitude, accuracy, speed, heading } = pos.coords;
        const point = { lat: latitude, lng: longitude, speed, heading, timestamp: pos.timestamp };

        if (typeof accuracy === 'number' && accuracy > MIN_ACCEPTABLE_ACCURACY_M) {
          setStatus(`ç²¾åº¦ãŒä½ã„ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆÂ±${Math.round(accuracy)}mï¼‰ã€‚`, true);
          renderHeading(point);
          return;
        }

        if (isLikelyGpsJump(point)) {
          setStatus('æ€¥ãªåº§æ¨™ã‚¸ãƒ£ãƒ³ãƒ—ã‚’æ¤œå‡ºã—ãŸãŸã‚ã€ã“ã®ç‚¹ã¯é™¤å¤–ã—ã¾ã—ãŸã€‚', true);
          renderHeading(point);
          return;
        }

        if (path.length > 0) totalDistanceM += haversineMeters(path[path.length - 1], point);

        lastUpdateAt = Date.now();
        path.push(point);
        marker.setLatLng([latitude, longitude]);
        polyline.setLatLngs(path.map((p) => [p.lat, p.lng]));
        map.panTo([latitude, longitude], { animate: true });

        latEl.textContent = latitude.toFixed(6);
        lngEl.textContent = longitude.toFixed(6);
        accuracyEl.textContent = `${Math.round(accuracy)} m`;
        speedEl.textContent = formatSpeed(speed);
        renderHeading(point);
        distanceEl.textContent = totalDistanceM >= 1000
          ? `${(totalDistanceM / 1000).toFixed(2)} km`
          : `${Math.round(totalDistanceM)} m`;

        renderHistory();
        setStatus(`è¿½è·¡ä¸­... ${new Date(pos.timestamp).toLocaleTimeString()} ã«æ›´æ–°`);
      }

      function handleError(error) {
        if (error.code === 3 && Date.now() - lastUpdateAt < STALE_TIMEOUT_MS) {
          setStatus('å†å–å¾—ä¸­ã§ã™...');
          return;
        }

        const mapError = {
          1: 'ä½ç½®æƒ…å ±ã®ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã§è¨±å¯ã—ã¦ãã ã•ã„ã€‚',
          2: 'ç¾åœ¨åœ°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã€‚GPSã‚„é€šä¿¡çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
          3: 'ä½ç½®æƒ…å ±ã®å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚',
        };
        setStatus(mapError[error.code] || 'ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', true);

        if (error.code === 3 && watchId !== null) {
          restartTrackingWatch();
          lastUpdateAt = Date.now();
        }
      }

      async function enableDeviceOrientationIfNeeded() {
        const needsPermission = typeof DeviceOrientationEvent !== 'undefined'
          && typeof DeviceOrientationEvent.requestPermission === 'function';

        if (needsPermission) {
          try {
            const result = await DeviceOrientationEvent.requestPermission();
            if (result !== 'granted') return;
          } catch {
            return;
          }
        }

        window.addEventListener('deviceorientationabsolute', (event) => {
          if (Number.isFinite(event.alpha)) {
            deviceHeadingDeg = (360 - event.alpha + 360) % 360;
            renderHeading(path[path.length - 1]);
          }
        });

        window.addEventListener('deviceorientation', (event) => {
          if (Number.isFinite(event.webkitCompassHeading)) {
            deviceHeadingDeg = event.webkitCompassHeading;
            renderHeading(path[path.length - 1]);
          } else if (Number.isFinite(event.alpha)) {
            deviceHeadingDeg = (360 - event.alpha + 360) % 360;
            renderHeading(path[path.length - 1]);
          }
        });
      }

      async function startTracking() {
        if (!('geolocation' in navigator)) {
          setStatus('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ± API ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚', true);
          return;
        }
        if (watchId !== null) return;

        await enableDeviceOrientationIfNeeded();
        restartTrackingWatch();
        ensureExtraPoll();
        ensureStaleCheckTimer();
        lastUpdateAt = Date.now();

        startBtn.disabled = true;
        stopBtn.disabled = false;
        setStatus('GPSã®è¿½è·¡ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚');
      }

      function stopTracking() {
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
          watchId = null;
        }
        clearExtraPoll();
        clearStaleCheckTimer();
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus('è¿½è·¡ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚');
      }

      function clearTrack() {
        path = [];
        totalDistanceM = 0;
        polyline.setLatLngs([]);
        distanceEl.textContent = '0 m';
        renderHistory();
        renderHeading();
        setStatus('è»Œè·¡ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚');
      }

      startBtn.addEventListener('click', startTracking);
      stopBtn.addEventListener('click', stopTracking);
      clearBtn.addEventListener('click', clearTrack);
      centerBtn.addEventListener('click', () => {
        if (path.length > 0) {
          const latest = path[path.length - 1];
          map.setView([latest.lat, latest.lng], 17);
        } else {
          setStatus('ã¾ã ç¾åœ¨åœ°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', true);
        }
      });

      renderHeading();
    </script>
  </body>
</html>
