<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ GPSã‚¢ãƒ—ãƒªï¼ˆå˜ä¸€HTMLç‰ˆï¼‰</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b1220;
        --card: #151f33;
        --text: #e8eefc;
        --muted: #9eadcc;
        --accent: #3b82f6;
        --accent-2: #22c55e;
        --danger: #f87171;
        --border: #2b3a59;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: Inter, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
        background: radial-gradient(circle at 10% 0%, #17294d 0, var(--bg) 40%);
        color: var(--text);
      }
      .container { width: min(1100px, 94%); margin: 1.25rem auto 2rem; display: grid; gap: 1rem; }
      .card { background: color-mix(in hsl, var(--card) 92%, black); border: 1px solid var(--border); border-radius: 14px; padding: 1rem; }
      h1 { margin: 0 0 0.7rem; }
      p { margin: 0; color: var(--muted); }
      .layout { display: grid; gap: 1rem; grid-template-columns: 1fr; }
      @media (min-width: 900px) { .layout { grid-template-columns: 1.45fr 1fr; } }
      #map { width: 100%; height: min(62vh, 520px); border-radius: 12px; border: 1px solid var(--border); }
      .controls { display: flex; flex-wrap: wrap; gap: 0.65rem; margin-bottom: 0.9rem; }
      button { border: none; background: var(--accent); color: #fff; border-radius: 10px; padding: 0.65rem 0.95rem; font-size: 0.95rem; font-weight: 700; cursor: pointer; }
      button.secondary { background: #334155; }
      button.success { background: var(--accent-2); }
      button:disabled { opacity: 0.65; cursor: not-allowed; }
      .status { min-height: 1.4rem; color: var(--muted); }
      .status.error { color: var(--danger); }
      .grid { display: grid; gap: 0.65rem; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
      .metric { border: 1px solid var(--border); border-radius: 10px; padding: 0.7rem; background: #10192b; }
      .label { display: block; color: var(--muted); font-size: 0.8rem; margin-bottom: 0.15rem; }
      .value { font-size: 1.02rem; font-weight: 700; }

      .compass-wrap {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 0.8rem;
        background: #10192b;
      }
      .compass {
        width: 130px;
        height: 130px;
        border: 2px solid #37507e;
        border-radius: 999px;
        margin: 0 auto;
        position: relative;
        background: radial-gradient(circle at center, #1f2f52 0%, #121d34 70%);
        box-shadow: inset 0 0 0 10px rgba(255, 255, 255, 0.03);
      }
      .compass-needle {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 4px;
        height: 52px;
        transform-origin: 50% calc(100% - 6px);
        transform: translate(-50%, -100%) rotate(0deg);
        transition: transform 180ms ease-out;
        border-radius: 4px;
        background: linear-gradient(to top, #e2e8f0 45%, #f87171 45%);
      }
      .compass-center {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 12px;
        height: 12px;
        border-radius: 999px;
        background: #e2e8f0;
        transform: translate(-50%, -50%);
      }
      .compass-mark {
        position: absolute;
        font-size: 0.72rem;
        color: #dbeafe;
        font-weight: 700;
      }
      .mark-n { left: 50%; top: 5px; transform: translateX(-50%); color: #fca5a5; }
      .mark-e { right: 7px; top: 50%; transform: translateY(-50%); }
      .mark-s { left: 50%; bottom: 5px; transform: translateX(-50%); }
      .mark-w { left: 7px; top: 50%; transform: translateY(-50%); }
      .compass-readout {
        text-align: center;
        margin-top: 0.55rem;
        font-weight: 700;
      }

      .history { margin-top: 0.8rem; max-height: 250px; overflow: auto; border: 1px solid var(--border); border-radius: 10px; }
      table { width: 100%; border-collapse: collapse; font-size: 0.84rem; }
      th, td { text-align: left; padding: 0.45rem 0.5rem; border-bottom: 1px solid #213150; white-space: nowrap; }
      th { position: sticky; top: 0; background: #172540; z-index: 1; }
      .footnote { font-size: 0.8rem; color: var(--muted); }
    </style>
  </head>
  <body>
    <main class="container">
      <section class="card">
        <h1>ğŸ“ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ GPSã‚¢ãƒ—ãƒªï¼ˆå˜ä¸€HTMLç‰ˆï¼‰</h1>
        <p>æ–¹è§’ã‚’ã‚³ãƒ³ãƒ‘ã‚¹è¡¨ç¤ºã«å¤‰æ›´ã—ã€é€Ÿåº¦ã¯GPSå€¤+æ¨å®šå€¤ã§å¸¸æ™‚è¡¨ç¤ºã™ã‚‹ã‚ˆã†ã«æ”¹å–„ã—ã¾ã—ãŸã€‚</p>
      </section>

      <section class="layout">
        <section class="card"><div id="map" aria-label="åœ°å›³"></div></section>
        <section class="card">
          <div class="controls">
            <button id="startBtn" class="success">è¿½è·¡é–‹å§‹</button>
            <button id="stopBtn" class="secondary" disabled>è¿½è·¡åœæ­¢</button>
            <button id="centerBtn" class="secondary">ç¾åœ¨åœ°ã¸ç§»å‹•</button>
            <button id="clearBtn" class="secondary">è»Œè·¡ã‚¯ãƒªã‚¢</button>
          </div>
          <div id="status" class="status">ã€Œè¿½è·¡é–‹å§‹ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</div>

          <div class="grid" aria-live="polite">
            <div class="metric"><span class="label">ç·¯åº¦</span><span class="value" id="lat">--</span></div>
            <div class="metric"><span class="label">çµŒåº¦</span><span class="value" id="lng">--</span></div>
            <div class="metric"><span class="label">ç²¾åº¦</span><span class="value" id="accuracy">--</span></div>
            <div class="metric"><span class="label">é€Ÿåº¦ï¼ˆå¸¸æ™‚æ›´æ–°ï¼‰</span><span class="value" id="speed">0.0 km/h</span></div>
            <div class="metric"><span class="label">ç´¯è¨ˆè·é›¢</span><span class="value" id="distance">0 m</span></div>
            <div class="compass-wrap">
              <span class="label">å‘ãï¼ˆã‚³ãƒ³ãƒ‘ã‚¹ï¼‰</span>
              <div class="compass" aria-hidden="true">
                <div class="compass-mark mark-n">N</div>
                <div class="compass-mark mark-e">E</div>
                <div class="compass-mark mark-s">S</div>
                <div class="compass-mark mark-w">W</div>
                <div id="compassNeedle" class="compass-needle"></div>
                <div class="compass-center"></div>
              </div>
              <div id="headingText" class="compass-readout">å–å¾—å¾…ã¡</div>
            </div>
          </div>

          <div class="history">
            <table>
              <thead><tr><th>æ™‚åˆ»</th><th>ç·¯åº¦</th><th>çµŒåº¦</th><th>é€Ÿåº¦</th></tr></thead>
              <tbody id="historyBody"><tr><td colspan="4">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</td></tr></tbody>
            </table>
          </div>
        </section>
      </section>

      <section class="card footnote">
        ä½ç½®æƒ…å ±ã¯ HTTPSï¼ˆã¾ãŸã¯ localhostï¼‰ã§åˆ©ç”¨ã§ãã¾ã™ã€‚ç«¯æœ«æ–¹ä½ãŒå–ã‚Œãªã„å ´åˆã¯ç§»å‹•æ–¹ä½ã§ã‚³ãƒ³ãƒ‘ã‚¹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
      </section>
    </main>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
      const statusEl = document.getElementById('status');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const centerBtn = document.getElementById('centerBtn');
      const clearBtn = document.getElementById('clearBtn');
      const historyBody = document.getElementById('historyBody');
      const latEl = document.getElementById('lat');
      const lngEl = document.getElementById('lng');
      const accuracyEl = document.getElementById('accuracy');
      const speedEl = document.getElementById('speed');
      const headingTextEl = document.getElementById('headingText');
      const distanceEl = document.getElementById('distance');
      const compassNeedleEl = document.getElementById('compassNeedle');

      const map = L.map('map').setView([35.681236, 139.767125], 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors',
      }).addTo(map);
      const marker = L.marker([35.681236, 139.767125]).addTo(map);
      const polyline = L.polyline([], { color: '#3b82f6', weight: 4 }).addTo(map);

      const MIN_ACCEPTABLE_ACCURACY_M = 150;
      const MAX_REASONABLE_SPEED_MPS = 55;
      const MIN_MOVEMENT_FOR_BEARING_M = 1;
      const STALE_TIMEOUT_MS = 25000;
      const EXTRA_POLL_MS = 3000;
      const SPEED_WINDOW_MS = 12000;
      const MIN_SPEED_DT_SEC = 2;
      const MIN_MOVEMENT_FOR_SPEED_M = 1.5;

      let watchId = null;
      let path = [];
      let totalDistanceM = 0;
      let lastUpdateAt = 0;
      let staleCheckTimer = null;
      let extraPollTimer = null;
      let speedTickerTimer = null;

      let deviceHeadingDeg = null;
      let lastHeading = null;
      let lastHeadingSource = '';
      let currentSpeedMps = 0;
      let targetSpeedMps = 0;
      let lastRawPoint = null;
      let rawTrack = [];
      let lastSpeedSource = 'æ¨å®š';

      function setStatus(message, isError = false) {
        statusEl.textContent = message;
        statusEl.classList.toggle('error', isError);
      }

      function headingToCardinal(deg) {
        const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
        return dirs[Math.round(deg / 45) % 8];
      }

      function formatSpeedFromMps(mps) {
        const safe = Math.max(0, Number.isFinite(mps) ? mps : 0);
        return `${(safe * 3.6).toFixed(1)} km/h`;
      }

      function bearingDegrees(from, to) {
        const toRad = (d) => (d * Math.PI) / 180;
        const toDeg = (r) => (r * 180) / Math.PI;
        const y = Math.sin(toRad(to.lng - from.lng)) * Math.cos(toRad(to.lat));
        const x = Math.cos(toRad(from.lat)) * Math.sin(toRad(to.lat))
          - Math.sin(toRad(from.lat)) * Math.cos(toRad(to.lat)) * Math.cos(toRad(to.lng - from.lng));
        return (toDeg(Math.atan2(y, x)) + 360) % 360;
      }

      function haversineMeters(a, b) {
        const R = 6371000;
        const toRad = (d) => (d * Math.PI) / 180;
        const dLat = toRad(b.lat - a.lat);
        const dLng = toRad(b.lng - a.lng);
        const aa = Math.sin(dLat / 2) ** 2
          + Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLng / 2) ** 2;
        return 2 * R * Math.atan2(Math.sqrt(aa), Math.sqrt(1 - aa));
      }

      function trimRawTrack(nowTs) {
        rawTrack = rawTrack.filter((p) => nowTs - p.timestamp <= SPEED_WINDOW_MS);
      }

      function setHeading(deg, source) {
        const normalized = ((deg % 360) + 360) % 360;
        lastHeading = normalized;
        lastHeadingSource = source;
        compassNeedleEl.style.transform = `translate(-50%, -100%) rotate(${normalized}deg)`;
        headingTextEl.textContent = `${Math.round(normalized)}Â° ${headingToCardinal(normalized)} (${source})`;
      }

      function renderHeading(currentPoint = null) {
        if (currentPoint && Number.isFinite(currentPoint.heading)
          && Number.isFinite(currentPoint.speed) && currentPoint.speed > 0.7) {
          setHeading(currentPoint.heading, 'GPS');
          return;
        }

        if (path.length >= 2) {
          const prev = path[path.length - 2];
          const curr = path[path.length - 1];
          const movementM = haversineMeters(prev, curr);
          if (movementM >= MIN_MOVEMENT_FOR_BEARING_M) {
            setHeading(bearingDegrees(prev, curr), 'ç§»å‹•');
            return;
          }
        }

        if (Number.isFinite(deviceHeadingDeg)) {
          setHeading(deviceHeadingDeg, 'ç«¯æœ«');
          return;
        }

        if (lastRawPoint && path.length > 0) {
          const current = path[path.length - 1];
          const movementM = haversineMeters(lastRawPoint, current);
          if (movementM >= MIN_MOVEMENT_FOR_BEARING_M) {
            setHeading(bearingDegrees(lastRawPoint, current), 'ç§»å‹•(è£œå®Œ)');
            return;
          }
        }

        if (Number.isFinite(lastHeading)) {
          headingTextEl.textContent = `${Math.round(lastHeading)}Â° ${headingToCardinal(lastHeading)} (${lastHeadingSource}:ä¿æŒ)`;
          return;
        }

        headingTextEl.textContent = 'å–å¾—å¾…ã¡';
      }

      function updateSpeedDisplay(mps, source = lastSpeedSource) {
        targetSpeedMps = Math.max(0, Number.isFinite(mps) ? mps : 0);
        lastSpeedSource = source;
      }

      function renderSpeed() {
        const staleSec = lastUpdateAt ? (Date.now() - lastUpdateAt) / 1000 : 999;

        if (watchId === null) {
          targetSpeedMps = 0;
        } else if (staleSec > 3) {
          targetSpeedMps *= 0.9;
          if (staleSec > 12) targetSpeedMps = 0;
        }

        currentSpeedMps += (targetSpeedMps - currentSpeedMps) * 0.35;
        if (currentSpeedMps < 0.02) currentSpeedMps = 0;

        const ageText = staleSec < 60 ? `ãƒ»${Math.floor(staleSec)}ç§’å‰` : '';
        speedEl.textContent = `${formatSpeedFromMps(currentSpeedMps)} (${lastSpeedSource}${ageText})`;
      }

      function restartTrackingWatch() {
        if (watchId !== null) navigator.geolocation.clearWatch(watchId);
        watchId = navigator.geolocation.watchPosition(updatePosition, handleError, {
          enableHighAccuracy: true,
          maximumAge: 2000,
          timeout: 20000,
        });
      }

      function ensureExtraPoll() {
        if (extraPollTimer !== null) return;
        extraPollTimer = setInterval(() => {
          if (watchId === null) return;
          navigator.geolocation.getCurrentPosition(updatePosition, (error) => {
            if (error.code !== 3) handleError(error);
          }, {
            enableHighAccuracy: true,
            maximumAge: 2000,
            timeout: 12000,
          });
        }, EXTRA_POLL_MS);
      }

      function clearExtraPoll() {
        if (extraPollTimer !== null) {
          clearInterval(extraPollTimer);
          extraPollTimer = null;
        }
      }

      function ensureSpeedTicker() {
        if (speedTickerTimer !== null) return;
        speedTickerTimer = setInterval(renderSpeed, 500);
      }

      function clearSpeedTicker() {
        if (speedTickerTimer !== null) {
          clearInterval(speedTickerTimer);
          speedTickerTimer = null;
        }
      }

      function ensureStaleCheckTimer() {
        if (staleCheckTimer !== null) return;
        staleCheckTimer = setInterval(() => {
          if (watchId === null || !lastUpdateAt) return;
          if (Date.now() - lastUpdateAt >= STALE_TIMEOUT_MS) {
            setStatus('æ›´æ–°ãŒæ­¢ã¾ã£ãŸãŸã‚å†æ¥ç¶šã—ã¦ã„ã¾ã™...');
            restartTrackingWatch();
            lastUpdateAt = Date.now();
          }
        }, 4000);
      }

      function clearStaleCheckTimer() {
        if (staleCheckTimer !== null) {
          clearInterval(staleCheckTimer);
          staleCheckTimer = null;
        }
      }

      function isLikelyGpsJump(point) {
        if (path.length === 0) return false;
        const prev = path[path.length - 1];
        const dtSec = Math.max((point.timestamp - prev.timestamp) / 1000, 1);
        const distanceM = haversineMeters(prev, point);
        const calcSpeed = distanceM / dtSec;
        const sensorSpeed = Number.isFinite(point.speed) ? point.speed : calcSpeed;
        return calcSpeed > MAX_REASONABLE_SPEED_MPS && sensorSpeed > MAX_REASONABLE_SPEED_MPS;
      }

      function renderHistory() {
        if (path.length === 0) {
          historyBody.innerHTML = '<tr><td colspan="4">ã¾ã è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</td></tr>';
          return;
        }
        historyBody.innerHTML = '';
        path.slice(-20).reverse().forEach((point) => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${new Date(point.timestamp).toLocaleTimeString()}</td><td>${point.lat.toFixed(6)}</td><td>${point.lng.toFixed(6)}</td><td>${formatSpeedFromMps(point.speedMps)}</td>`;
          historyBody.appendChild(tr);
        });
      }

      function smoothSpeed(nextMps) {
        if (!Number.isFinite(nextMps)) return currentSpeedMps;
        const alpha = 0.45;
        return currentSpeedMps * (1 - alpha) + nextMps * alpha;
      }

      function resolveSpeedMps(point) {
        const gpsSpeed = Number.isFinite(point.speed) && point.speed >= 0 ? point.speed : null;

        let estimated = 0;
        let base = null;
        for (let i = 0; i < rawTrack.length; i += 1) {
          const candidate = rawTrack[i];
          const dtSec = (point.timestamp - candidate.timestamp) / 1000;
          if (dtSec >= MIN_SPEED_DT_SEC) {
            base = candidate;
            break;
          }
        }

        if (base) {
          const dtSec = Math.max((point.timestamp - base.timestamp) / 1000, MIN_SPEED_DT_SEC);
          const distanceM = haversineMeters(base, point);
          if (distanceM >= MIN_MOVEMENT_FOR_SPEED_M) {
            estimated = distanceM / dtSec;
          }
        } else if (lastRawPoint) {
          const dtSec = Math.max((point.timestamp - lastRawPoint.timestamp) / 1000, 0.5);
          const distanceM = haversineMeters(lastRawPoint, point);
          if (distanceM >= MIN_MOVEMENT_FOR_SPEED_M) {
            estimated = distanceM / dtSec;
          }
        }

        if (gpsSpeed !== null && gpsSpeed > 0.3) {
          return { value: gpsSpeed, source: 'GPS' };
        }
        if (estimated > 0) {
          return { value: estimated, source: 'æ¨å®š' };
        }
        if (gpsSpeed !== null) {
          return { value: gpsSpeed, source: 'GPS' };
        }
        return { value: 0, source: 'æ¨å®š' };
      }

      function updatePosition(pos) {
        const { latitude, longitude, accuracy, speed, heading } = pos.coords;
        const point = { lat: latitude, lng: longitude, speed, heading, accuracy, timestamp: pos.timestamp, speedMps: 0 };

        rawTrack.push(point);
        trimRawTrack(point.timestamp);

        const speedInfo = resolveSpeedMps(point);
        const smoothed = smoothSpeed(speedInfo.value);
        updateSpeedDisplay(smoothed, speedInfo.source);

        if (typeof accuracy === 'number' && accuracy > MIN_ACCEPTABLE_ACCURACY_M) {
          setStatus(`ç²¾åº¦ãŒä½ã„ãŸã‚ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸï¼ˆÂ±${Math.round(accuracy)}mï¼‰ã€‚`, true);
          renderHeading(point);
          lastRawPoint = point;
          return;
        }

        if (isLikelyGpsJump(point)) {
          setStatus('æ€¥ãªåº§æ¨™ã‚¸ãƒ£ãƒ³ãƒ—ã‚’æ¤œå‡ºã—ãŸãŸã‚ã€ã“ã®ç‚¹ã¯é™¤å¤–ã—ã¾ã—ãŸã€‚', true);
          renderHeading(point);
          lastRawPoint = point;
          return;
        }

        if (path.length > 0) totalDistanceM += haversineMeters(path[path.length - 1], point);

        point.speedMps = smoothed;
        lastUpdateAt = Date.now();
        path.push(point);
        lastRawPoint = point;
        marker.setLatLng([latitude, longitude]);
        polyline.setLatLngs(path.map((p) => [p.lat, p.lng]));
        map.panTo([latitude, longitude], { animate: true });

        latEl.textContent = latitude.toFixed(6);
        lngEl.textContent = longitude.toFixed(6);
        accuracyEl.textContent = `${Math.round(accuracy)} m`;
        renderHeading(point);
        distanceEl.textContent = totalDistanceM >= 1000
          ? `${(totalDistanceM / 1000).toFixed(2)} km`
          : `${Math.round(totalDistanceM)} m`;

        renderHistory();
        setStatus(`è¿½è·¡ä¸­... ${new Date(pos.timestamp).toLocaleTimeString()} ã«æ›´æ–°`);
      }

      function handleError(error) {
        if (error.code === 3 && Date.now() - lastUpdateAt < STALE_TIMEOUT_MS) {
          setStatus('å†å–å¾—ä¸­ã§ã™...');
          return;
        }

        const mapError = {
          1: 'ä½ç½®æƒ…å ±ã®ä½¿ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã§è¨±å¯ã—ã¦ãã ã•ã„ã€‚',
          2: 'ç¾åœ¨åœ°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã€‚GPSã‚„é€šä¿¡çŠ¶æ…‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
          3: 'ä½ç½®æƒ…å ±ã®å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚',
        };
        setStatus(mapError[error.code] || 'ä½ç½®æƒ…å ±ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', true);

        if (error.code === 3 && watchId !== null) {
          restartTrackingWatch();
          lastUpdateAt = Date.now();
        }
      }

      async function enableDeviceOrientationIfNeeded() {
        const needsPermission = typeof DeviceOrientationEvent !== 'undefined'
          && typeof DeviceOrientationEvent.requestPermission === 'function';

        if (needsPermission) {
          try {
            const result = await DeviceOrientationEvent.requestPermission();
            if (result !== 'granted') return;
          } catch {
            return;
          }
        }

        window.addEventListener('deviceorientationabsolute', (event) => {
          if (Number.isFinite(event.alpha)) {
            deviceHeadingDeg = (360 - event.alpha + 360) % 360;
            renderHeading(path[path.length - 1]);
          }
        });

        window.addEventListener('deviceorientation', (event) => {
          if (Number.isFinite(event.webkitCompassHeading)) {
            deviceHeadingDeg = event.webkitCompassHeading;
            renderHeading(path[path.length - 1]);
          } else if (Number.isFinite(event.alpha)) {
            deviceHeadingDeg = (360 - event.alpha + 360) % 360;
            renderHeading(path[path.length - 1]);
          }
        });
      }

      async function startTracking() {
        if (!('geolocation' in navigator)) {
          setStatus('ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ± API ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚', true);
          return;
        }
        if (watchId !== null) return;

        await enableDeviceOrientationIfNeeded();
        restartTrackingWatch();
        ensureExtraPoll();
        ensureStaleCheckTimer();
        ensureSpeedTicker();
        lastUpdateAt = Date.now();

        startBtn.disabled = true;
        stopBtn.disabled = false;
        setStatus('GPSã®è¿½è·¡ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚');
      }

      function stopTracking() {
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
          watchId = null;
        }
        clearExtraPoll();
        clearStaleCheckTimer();
        clearSpeedTicker();
        updateSpeedDisplay(0, 'åœæ­¢');
        renderSpeed();
        startBtn.disabled = false;
        stopBtn.disabled = true;
        setStatus('è¿½è·¡ã‚’åœæ­¢ã—ã¾ã—ãŸã€‚');
      }

      function clearTrack() {
        path = [];
        lastRawPoint = null;
        rawTrack = [];
        totalDistanceM = 0;
        polyline.setLatLngs([]);
        distanceEl.textContent = '0 m';
        updateSpeedDisplay(0, 'åœæ­¢');
        renderSpeed();
        renderHistory();
        renderHeading();
        setStatus('è»Œè·¡ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚');
      }

      startBtn.addEventListener('click', startTracking);
      stopBtn.addEventListener('click', stopTracking);
      clearBtn.addEventListener('click', clearTrack);
      centerBtn.addEventListener('click', () => {
        if (path.length > 0) {
          const latest = path[path.length - 1];
          map.setView([latest.lat, latest.lng], 17);
        } else {
          setStatus('ã¾ã ç¾åœ¨åœ°ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', true);
        }
      });

      renderHeading();
      updateSpeedDisplay(0, 'å¾…æ©Ÿ');
      renderSpeed();
    </script>
  </body>
</html>
